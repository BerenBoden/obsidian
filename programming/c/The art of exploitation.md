### *GDB debugger*
After cloning the `https://github.com/bminor/binutils-gdb` repository and compiling it on my linux system, I was able to run gdb on my compiled C program to show the state of the processor registers right before the program starts.

The C program was just a simple function that prints `Hello world` 10 times.
```
#include <stdio.h>

int main()
{
    int i;
    for(i=0; i < 10; i++)
    {
        puts("Hello world");
    }
    return 0;
}
```

I compiled with `gcc 0x250.c` and run gdb against `a.out`. These are the results I recieved:
```
gdb -q ./a.out
Reading symbols from ./a.out...

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.archlinux.org>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
(No debugging symbols found in ./a.out)
(gdb) break main
Breakpoint 1 at 0x113d
(gdb) run
Starting program: /home/bricky/projects/the-art-of-exploitation/a.out 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Breakpoint 1, 0x000055555555513d in main ()
(gdb) info registers
rax            0x555555555139      93824992235833
rbx            0x7fffffffdc28      140737488346152
rcx            0x555555557dd8      93824992247256
rdx            0x7fffffffdc38      140737488346168
rsi            0x7fffffffdc28      140737488346152
rdi            0x1                 1
rbp            0x7fffffffdb10      0x7fffffffdb10
rsp            0x7fffffffdb10      0x7fffffffdb10
r8             0x0                 0
r9             0x7ffff7fcecd0      140737353936080
r10            0x7fffffffd840      140737488345152
r11            0x206               518
r12            0x0                 0
r13            0x7fffffffdc38      140737488346168
r14            0x7ffff7ffd000      140737354125312
r15            0x555555557dd8      93824992247256
rip            0x55555555513d      0x55555555513d <main+4>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
```

The program has been stopped before the `main` function is executed, then I have displayed the processor registers and their current states by running `info registers`.

Here is some information on each register:
- **General Purpose Registers:**
    - **`rax`**: The Accumulator Register. It's used in arithmetic operations, function return values, and is the extended version of the 32-bit `eax` register.
    - **`rbx`**: The Base Register. It's often used to hold data that needs to be accessed globally.
    - **`rcx`**: The Counter Register. It's used in loops and string operations as a counter and is the extended version of the 32-bit `ecx` register.
    - **`rdx`**: The Data Register. It's used for input/output operations and is the extended version of the 32-bit `edx` register.
    - **`rsi`**: The Source Index. Used in string operations to point to the source data in memory.
    - **`rdi`**: The Destination Index. Used in string operations to point to the destination in memory.
    - **`rbp`**: The Base Pointer. It's used to point to the base of the current function's stack frame.
    - **`rsp`**: The Stack Pointer. Points to the top of the current stack frame.
    - **`r8` to `r15`**: Additional general-purpose registers in x86_64 architecture, expanding the available registers for general use.
- **Special Purpose Registers:**
    - **`rip`**: The Instruction Pointer. It points to the next instruction to be executed.
    - **`eflags`**: A set of flags used to store the results of operations and control the processor's state. The `PF` (Parity Flag), `ZF` (Zero Flag), and `IF` (Interrupt Enable Flag) are among the status flags that indicate the outcome of the last arithmetic operation or control how the CPU responds to interrupts.
    - **`cs`**: The Code Segment register. It's part of the segmentation mechanism, indicating the memory area where the current code is executing.
    - **`ss`**: The Stack Segment register. It points to the segment of the stack.
    - **`ds`**: The Data Segment register. It was traditionally used to point to the data segment of the memory where data is stored. In modern flat memory models, segmentation is less commonly used but still part of the architecture.

I also wanted to see the difference between this and a 32bit program, so I compiled the same program, but intentionally made it a 32bit program. 
```
gcc -m32 -g 0x250.c -o b.out
gdb -q ./b.out              
Reading symbols from ./b.out...
(gdb) break main
Breakpoint 1 at 0x11aa: file 0x250.c, line 6.
(gdb) run
Starting program: /home/bricky/projects/the-art-of-exploitation/b.out 

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.archlinux.org>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for /lib/ld-linux.so.2
Downloading separate debug info for system-supplied DSO at 0xf7fc7000                                                                                                                  
Downloading separate debug info for /usr/lib32/libc.so.6                                                                                                                               
[Thread debugging using libthread_db enabled]                                                                                                                                          
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Breakpoint 1, main () at 0x250.c:6
6           for(i=0; i < 10; i++)
(gdb) info registers
eax            0x5655618d          1448436109
ecx            0xffffcd20          -13024
edx            0xffffcd40          -12992
ebx            0x56558ff4          1448447988
esp            0xffffccf0          0xffffccf0
ebp            0xffffcd08          0xffffcd08
esi            0xffffcddc          -12836
edi            0xf7ffcb80          -134231168
eip            0x565561aa          0x565561aa <main+29>
eflags         0x202               [ IF ]
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x63                99
(gdb) 
```

The difference between these two programs is that `a.out` is 64bit and `b.out` is 32bit. 
- **32-bit (x86) Architecture**: Uses 32-bit registers like `eax`, `ebx`, `ecx`, `edx`, etc. This architecture allows addressing a maximum of 4 GB of memory directly.
- **64-bit (x86_64) Architecture**: Extends the x86 architecture with 64-bit registers, prefixed with `r` (e.g., `rax`, `rbx`, `rcx`, `rdx`, etc.), allowing for a much larger addressable memory space.

You can set the syntax for the gdb debugger by using the command `(gdb) set disassembly-flavor intel`. I have chose intel syntax over AT&T as it is easier to read. You can also set this for every time that it starts up by editing the `.gdbinit` file. `echo "set disassembly-flavor intel" > ~/.gdbinit`
